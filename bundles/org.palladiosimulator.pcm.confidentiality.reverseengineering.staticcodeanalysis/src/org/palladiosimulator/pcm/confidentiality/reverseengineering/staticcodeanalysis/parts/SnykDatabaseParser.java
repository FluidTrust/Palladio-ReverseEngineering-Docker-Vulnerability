package org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.parts;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadLocalRandom;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

public class SnykDatabaseParser {

	/**
	 * Parses the specified web entry for vulnerability attributes. The parser is
	 * built for parsing the Snyk vulnerability database website.
	 * 
	 * @param path to the vulnerability Snyk website entry
	 * @return a map of attributes and their values.
	 */
	public Map<String, String> parseWebEntry(String path) {

		ExecutorService executor = Executors.newSingleThreadExecutor();
		Callable<Document> callable = new SnykDatabaseRequestCallable(path);

		Future<Document> future = executor.submit(callable);

		Document doc = null;
		Map<String, String> attributes = new HashMap<String, String>();

		try {
			doc = future.get();
		} catch (InterruptedException | ExecutionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		executor.shutdown();

		if (doc != null) {
			attributes = parseAttributes(doc);
		}

		return attributes;
	}

	public Map<String, String> parseAttributes(Document doc) {
		Map<String, String> attributes = new HashMap<String, String>();

		Elements breakdownItems = doc.select(".cvss-breakdown__item");
		for (Element item : breakdownItems) {
			String attributeTitle = item.select(".cvss-breakdown__title").html();
			String attributeValue = item.select(".cvss-breakdown__desc").html();
			attributes.put(attributeTitle, attributeValue);
		}

		return attributes;
	}

	private class SnykDatabaseRequestCallable implements Callable<Document> {

		String path;

		public SnykDatabaseRequestCallable(String path) {
			this.path = path;
		}

		@Override
		public Document call() {

			Document doc = null;

			long randomTimeout = ThreadLocalRandom.current().nextLong(0, 1500);
			try {
				Thread.sleep(randomTimeout);
			} catch (InterruptedException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

			try {
				doc = Jsoup.connect(path).get();

			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			return doc;
		}
	}
}
