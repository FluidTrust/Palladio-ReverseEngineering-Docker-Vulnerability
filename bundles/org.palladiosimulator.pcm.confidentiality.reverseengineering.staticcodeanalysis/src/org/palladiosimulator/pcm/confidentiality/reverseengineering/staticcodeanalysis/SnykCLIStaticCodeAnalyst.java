package org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.AttackerSystemSpecificationContainer;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.impl.AttackerFactoryImpl;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.SystemIntegration;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.impl.PCMElementImpl;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.impl.PcmIntegrationFactoryImpl;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.impl.VulnerabilitySystemIntegrationImpl;
import org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.iface.IStaticCodeAnalysisIssue;
import org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.iface.IStaticCodeAnalysisResult;
import org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.iface.IStaticCodeAnalyst;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.core.entity.Entity;
import org.palladiosimulator.pcm.repository.RepositoryComponent;
import org.palladiosimulator.pcm.system.impl.SystemImpl;

public class SnykCLIStaticCodeAnalyst implements IStaticCodeAnalyst {

    /**
     * The Logger for this analyst.
     */
    private static final Logger LOG = Logger.getLogger(SnykCLIStaticCodeAnalyst.class);

    /**
     * The path to the snyk executable.
     */
    private Path snykLocation;

    /**
     * The path to the output directory.
     */
    private Path outputLocation;

    /**
     * Creates a SnykCLIStaticCodeAnalyst which will use the specified snyk executable.
     *
     * @param snykLocation
     *            a path to a snyk executable
     * @param outputLocation
     *            a path to the output directory
     */
    public SnykCLIStaticCodeAnalyst(Path snykLocation, Path outputLocation) {
        this.snykLocation = snykLocation;
        this.outputLocation = outputLocation;
    }

    @Override
    public IStaticCodeAnalysisResult analyze(Map<Entity, Set<Path>> entityPaths) {
        return analyze(entityPaths, true);
    }

    public IStaticCodeAnalysisResult analyze(Map<Entity, Set<Path>> entityPaths, boolean saveResult) {
        StaticCodeAnalyisResult result = null;

        for (Entity entity : entityPaths.keySet()) {
            Set<Path> paths = entityPaths.get(entity);
            for (Path path : paths) {
                if (path.getFileName()
                    .toString()
                    .equals("pom.xml")
                        || path.getFileName()
                            .toString()
                            .equals("Dockerfile")) {
                    String output = this.runCLICommand(path);
                    final StaticCodeAnalyisResult thisResult = this.parseSnykCLIOutput(output);
                    result = thisResult;
                    if (saveResult) {
                        AttackerSystemSpecificationContainer container = AttackerFactoryImpl.eINSTANCE
                            .createAttackerSystemSpecificationContainer();
                        // This is a writable list
                        List<SystemIntegration> systemIntegrations = (List<SystemIntegration>) container
                            .getVulnerabilities();
                        if (entity instanceof SystemImpl) {
                            ((SystemImpl) entity).getAssemblyContexts__ComposedStructure()
                                .forEach(x -> systemIntegrations.addAll(annotateResultToEntity(x, thisResult)));
                        } else {
                            systemIntegrations.addAll(annotateResultToEntity(entity, result));
                        }
                        // Use the name of the parent directory of the pom.xml/Dockerfile as
                        // identifier for the model file
                        saveModel(path.getParent()
                            .getFileName()
                            .toString(), container);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Annotates a StaticCodeAnalyisResult to an Palladio Entity. Therefore the vulnerabilities of
     * the result are looked up in Snyk's vulnerability database. The found results will be stored
     * in Vulnerability objects that then will be annotated to the specified entity with the help of
     * VulnerabilitySystemIntegrations
     * 
     * @param entity
     *            the vulnerabilities will be annotated to
     * @param result
     *            of a Snyk analysis
     * @return the constructed VulnerabilitySystemIntegration
     */
    private List<VulnerabilitySystemIntegrationImpl> annotateResultToEntity(Entity entity,
            StaticCodeAnalyisResult result) {
        List<VulnerabilitySystemIntegrationImpl> sysIntegs = new ArrayList<>();
        for (var issue : result.getIssues()) {
            VulnerabilitySystemIntegrationImpl sysInteg = (VulnerabilitySystemIntegrationImpl) PcmIntegrationFactoryImpl.eINSTANCE
                .createVulnerabilitySystemIntegration();

            Vulnerability vul = getVulnerability(issue.getUrl());
            if (vul != null) {
                sysInteg.setVulnerability(vul);
            }
            PCMElementImpl pcmElement = (PCMElementImpl) PcmIntegrationFactoryImpl.eINSTANCE.createPCMElement();

            if ((entity instanceof RepositoryComponent)) {
                pcmElement.setBasiccomponent((RepositoryComponent) entity);
            } else if (entity instanceof AssemblyContext) {
                pcmElement.setAssemblycontext((AssemblyContext) entity);
            } else
                throw new IllegalArgumentException("Please use RepositoryComponents or AssemblyContexts as arguments");

            sysInteg.setPcmelement(pcmElement);
            sysIntegs.add(sysInteg);
        }
        return sysIntegs;
    }

    /**
     * Crawls the specified Snyk web site for the CWE and CVE identifiers of a vulnerability. Then,
     * if the vulnerability has a CWE identifier, it looks up the details of that and returns a
     * CWEVulnerability containing them. Otherwise, a CVE identifier is created and returned.
     * 
     * @param url
     *            the URL of the Snyk web site for a vulnerability
     * @return the details of the vulnerability or {@code null} if no identifier could be found
     */
    private Vulnerability getVulnerability(String url) {
        NvdVulnerabilityDatabase database = new NvdVulnerabilityDatabase();
        Document doc = null;
        try {
            doc = Jsoup.connect(url)
                .get();
        } catch (IOException e) {
            LOG.error("Could not get vulnerability definitions from \"" + url + "\"!");
            return null;
        }
        List<String> identifiers = doc.select("a[href]")
            .stream()
            .map(x -> x.ownText())
            .collect(Collectors.toList());
        for (String identifier : identifiers) {
            /*
             * if (identifier.startsWith("CWE-")) { return database.getCWEVulnerability(identifier);
             * } else
             */
            if (identifier.startsWith("CVE-")) {
                return database.getCVEVulnerability(identifier);
            }
        }
        return null;
    }

    /**
     * Takes a path and starts the Snyk CLI command for this path. To run the command a process is
     * build and started. The output is read with the help of a BufferedReader. The complete Snyk
     * output will be returned.
     * 
     * @param path
     *            that will be scanned from Snyk
     * @return Snyk output
     */
    private String runCLICommand(Path path) {
        if (path.toFile()
            .exists()) {
            ProcessBuilder processBuilder = new ProcessBuilder();
            processBuilder.directory(path.getParent()
                .toFile());
            processBuilder.command(snykLocation.toString(), "test", "--file=" + path);

            try {

                Process process = processBuilder.start();

                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

                String line;
                StringBuilder sb = new StringBuilder();
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    sb.append(line)
                        .append('\n');
                }

                int exitCode = process.waitFor();
                System.out.println("\nExited with error code : " + exitCode);
                return sb.toString();

            } catch (IOException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("File does not exist.");
        }

        return "";
    }

    // Declaring multiple patterns for RegEx search. All patterns are concatenated
    // to one full pattern that is used to parse the Snyk output.
    private static String packagePattern = "(?<package>[a-zA-Z0-9\\.:@\\-]*)";
    private static String issueNamePattern = "(?<name>[a-z A-Z\\(\\)]*)";
    private static String severityPattern = "\\[(?<severity>[a-z A-Z]*)\\]";
    private static String urlPattern = "\\[(?<url>(?:https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|])\\]";
    private static String fullOutputPattern = issueNamePattern + severityPattern + urlPattern + " in " + packagePattern;

    /**
     * Takes Snyk CLI output and parses it. StaticCodeAnalysisResults will be built out of the
     * parsed information.
     * 
     * @param output
     *            of a Snyk CLI process
     * @return StaticCodeAnalyisResult object containing all parsed data
     */
    // Set pulbic for testing
    public StaticCodeAnalyisResult parseSnykCLIOutput(String output) {
        ArrayList<IStaticCodeAnalysisIssue> issues = new ArrayList<>();

        // Possibility to scan for package manager
        String packetManager = null;

        if (output == null || output.isEmpty()) {
            return new StaticCodeAnalyisResult(issues, packetManager);
        }

        // Snyk CLI lists the issues and uses the '\u2717' character as bullet points.
        // The console output is converted to UTF-8 if the regex did not work.
        // The encoding is not reliable. For example:
        // when running the unit tests via surefire, only the first option works,
        // when using the snyk binary on Windows, only the second one does.
        String[] issueStrings = output.split("\\u2717");
        if (issueStrings.length <= 1 /* no occurrence of \u2717 in the default encoding */) {
            issueStrings = new String(output.getBytes(), StandardCharsets.UTF_8).split("\\u2717");
        }

        Pattern pattern = Pattern.compile(fullOutputPattern);

        // Start from index 1 to skip first non-issue String
        for (int i = 1; i < issueStrings.length; i++) {
            Matcher matcher = pattern.matcher(issueStrings[i]);
            if (matcher.find()) {
                SnykIssue issue = new SnykIssue(matcher.group("url"), matcher.group("name"), matcher.group("package"),
                        matcher.group("severity"));
                issues.add(issue);
            }
        }

        return new StaticCodeAnalyisResult(issues, packetManager);
    }

    /**
     * Saving the specified model with a name
     * 
     * @param name
     *            the name to include in the file name
     * @param model
     *            the model to save
     */
    private void saveModel(String name, AttackerSystemSpecificationContainer model) {

        Resource.Factory.Registry reg = Resource.Factory.Registry.INSTANCE;
        Map<String, Object> m = reg.getExtensionToFactoryMap();
        m.put("vulnerabilitySystemIntegration", new XMIResourceFactoryImpl());

        // Obtain a new resource set
        ResourceSet resSet = new ResourceSetImpl();

        // create a resource
        // Note: this convoluted path conversion is for Windows machines
        Resource resource = resSet.createResource(org.eclipse.emf.common.util.URI
            .createURI(outputLocation.resolve("repository_" + name + ".vulnerabilitySystemIntegration")
                .toUri()
                .toString()));

        resource.getContents()
            .add(model);

        // now save the content.
        try {
            resource.save(Collections.emptyMap());
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    @Override
    public IStaticCodeAnalysisResult analyze(String path) {
        // TODO Auto-generated method stub
        return null;
    }

}
